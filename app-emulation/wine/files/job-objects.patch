diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index e621689..ff845bb 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -32,6 +32,7 @@
 #include "wincon.h"
 #include "winnls.h"
 #include "winternl.h"
+#include "winnt.h"
 
 #include "wine/test.h"
 
@@ -66,6 +67,11 @@ static BOOL   (WINAPI *pVirtualFreeEx)(HANDLE, LPVOID, SIZE_T, DWORD);
 static BOOL   (WINAPI *pQueryFullProcessImageNameA)(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize);
 static BOOL   (WINAPI *pQueryFullProcessImageNameW)(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize);
 static DWORD  (WINAPI *pK32GetProcessImageFileNameA)(HANDLE,LPSTR,DWORD);
+static HANDLE (WINAPI *pCreateJobObjectW)( LPSECURITY_ATTRIBUTES sa, LPCWSTR name );
+static BOOL   (WINAPI *pAssignProcessToJobObject)( HANDLE job, HANDLE process );
+static BOOL   (WINAPI *pSetInformationJobObject)( HANDLE job, JOBOBJECTINFOCLASS class, LPVOID info, DWORD len );
+static BOOL   (WINAPI *pIsProcessInJob)( HANDLE process, HANDLE job, PBOOL result );
+static BOOL   (WINAPI *pTerminateJobObject)( HANDLE job, UINT exit_code );
 static struct _TEB * (WINAPI *pNtCurrentTeb)(void);
 
 /* ############################### */
@@ -212,6 +218,11 @@ static BOOL init(void)
     pQueryFullProcessImageNameA = (void *) GetProcAddress(hkernel32, "QueryFullProcessImageNameA");
     pQueryFullProcessImageNameW = (void *) GetProcAddress(hkernel32, "QueryFullProcessImageNameW");
     pK32GetProcessImageFileNameA = (void *) GetProcAddress(hkernel32, "K32GetProcessImageFileNameA");
+    pCreateJobObjectW = (void *) GetProcAddress(hkernel32, "CreateJobObjectW");
+    pAssignProcessToJobObject = (void *) GetProcAddress(hkernel32, "AssignProcessToJobObject");
+    pSetInformationJobObject = (void *) GetProcAddress(hkernel32, "SetInformationJobObject");
+    pIsProcessInJob = (void *) GetProcAddress(hkernel32, "IsProcessInJob");
+    pTerminateJobObject = (void *) GetProcAddress(hkernel32, "TerminateJobObject");
     pNtCurrentTeb = (void *)GetProcAddress( hntdll, "NtCurrentTeb" );
     return TRUE;
 }
@@ -262,9 +273,18 @@ static void     doChild(const char* file, const char* option)
     WCHAR               *ptrW, *ptrW_save;
     char                bufA[MAX_PATH];
     WCHAR               bufW[MAX_PATH];
-    HANDLE              hFile = CreateFileA(file, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    HANDLE              hFile;
     BOOL ret;
 
+    if (option && strcmp(option, "wait") == 0) {
+        /* for job object tests */
+        Sleep(3000);
+        return;
+    }
+    if (option && strcmp(option, "exit") == 0)
+        return;
+
+    hFile = CreateFileA(file, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
     if (hFile == INVALID_HANDLE_VALUE) return;
 
     /* output of startup info (Ansi) */
@@ -2112,6 +2132,155 @@ void test_StartupNoConsole(void)
 
 }
 
+static void _test_job_completion(HANDLE IOPort, DWORD eKey, HANDLE eVal, DWORD eOverlap, DWORD wait)
+{
+    DWORD CompletionKey, ret;
+    ULONG_PTR CompletionValue;
+    LPOVERLAPPED Overlapped;
+
+    ret = GetQueuedCompletionStatus(IOPort, &CompletionKey, &CompletionValue, &Overlapped, wait);
+    winetest_ok(ret, "GetQueuedCompletionStatus: %x\n", GetLastError());
+    if(ret) {
+        winetest_ok(eKey == CompletionKey &&
+            (ULONG_PTR)eVal == CompletionValue &&
+            eOverlap == (DWORD_PTR)Overlapped,
+            "Unexpected completion event: %x, %p, %p\n",
+            CompletionKey, (void*)CompletionValue, (void*)Overlapped);
+    }
+}
+
+#define test_job_completion(a, b, c, d, e) (winetest_set_location(__FILE__,__LINE__), 0) ? 0 : _test_job_completion(a, b, c, d, e)
+
+static void test_JobObject(void) {
+    JOBOBJECT_ASSOCIATE_COMPLETION_PORT Port;
+    JOBOBJECT_EXTENDED_LIMIT_INFORMATION info;
+    PROCESS_INFORMATION pi[4];
+    STARTUPINFO si[4] = {{0}};
+    HANDLE JobObject;
+    HANDLE IOPort;
+    HANDLE thisProcess;
+    BOOL ret;
+    BOOL out;
+    char buffer[MAX_PATH];
+
+    if(!pCreateJobObjectW) {
+        win_skip("No job object support\n");
+        return;
+    }
+
+    sprintf(buffer, "\"%s\" tests/process.c ignored \"%s\"", selfname, "wait");
+
+    IOPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);
+    ok(IOPort != NULL, "CreateIoCompletionPort (%d)", GetLastError());
+
+    JobObject = pCreateJobObjectW(NULL, NULL);
+    ok(JobObject != NULL, "CreateJobObject (%d)\n", GetLastError());
+
+    Port.CompletionKey = JobObject;
+    Port.CompletionPort = IOPort;
+    ret = pSetInformationJobObject(JobObject, JobObjectAssociateCompletionPortInformation, &Port, sizeof(Port));
+    ok(ret, "SetInformationJobObject (%d)\n", GetLastError());
+
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si[0], &pi[0]),
+        "CreateProcess (%d)\n", GetLastError());
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si[1], &pi[1]),
+        "CreateProcess (%d)\n", GetLastError());
+
+    if(pIsProcessInJob) {
+        ret = pIsProcessInJob(pi[0].hProcess, JobObject, &out);
+        ok(ret && !out, "IsProcessInJob: expected false (%d)\n", GetLastError());
+    }
+
+    ret = pAssignProcessToJobObject(JobObject, pi[0].hProcess);
+    ok(ret, "AssignProcessToJobObject (%d)\n", GetLastError());
+
+    if(pIsProcessInJob) {
+        ret = pIsProcessInJob(pi[0].hProcess, JobObject, &out);
+        ok(ret && out, "IsProcessInJob: expected true (%d)\n", GetLastError());
+    }
+
+    ret = pAssignProcessToJobObject(JobObject, pi[1].hProcess);
+    ok(ret, "AssignProcessToJobObject (%d)\n", GetLastError());
+
+    ok(TerminateProcess(pi[0].hProcess, 0), "TerminateProcess (%d)\n", GetLastError());
+    winetest_wait_child_process(pi[0].hProcess);
+    ok(TerminateProcess(pi[1].hProcess, 0), "TerminateProcess (%d)\n", GetLastError());
+    winetest_wait_child_process(pi[1].hProcess);
+
+    if(pIsProcessInJob) {
+        ret = pIsProcessInJob(pi[0].hProcess, JobObject, &out);
+        ok(ret && out, "IsProcessInJob: expected true (%d)\n", GetLastError());
+    }
+
+    test_job_completion(IOPort, JOB_OBJECT_MSG_NEW_PROCESS,  JobObject, pi[0].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_NEW_PROCESS,  JobObject, pi[1].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_EXIT_PROCESS, JobObject, pi[0].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_EXIT_PROCESS, JobObject, pi[1].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO, JobObject, 0, 100);
+
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si[2], &pi[2]),
+        "CreateProcess: (%d)\n", GetLastError());
+
+    ret = pAssignProcessToJobObject(JobObject, pi[2].hProcess);
+    ok(ret, "AssignProcessToJobObject (%d)\n", GetLastError());
+
+    ret = pTerminateJobObject( JobObject, 0 );
+    ok(ret, "TerminateJobObject (%d)\n", GetLastError());
+
+    winetest_wait_child_process(pi[2].hProcess);
+
+    test_job_completion(IOPort, JOB_OBJECT_MSG_NEW_PROCESS,  JobObject, pi[2].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO, JobObject, 0, 100);
+
+    thisProcess = OpenProcess(PROCESS_SET_QUOTA | PROCESS_TERMINATE,
+                              FALSE, GetCurrentProcessId());
+
+    ret = pAssignProcessToJobObject(JobObject, thisProcess);
+    ok(ret, "AssignProcessToJobObject (%d)\n", GetLastError());
+
+    sprintf(buffer, "\"%s\" tests/process.c ignored \"%s\"", selfname, "exit");
+
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si[3], &pi[3]),
+        "CreateProcess: (%d)\n", GetLastError());
+
+    winetest_wait_child_process(pi[3].hProcess);
+
+    test_job_completion(IOPort, JOB_OBJECT_MSG_NEW_PROCESS,  JobObject, GetCurrentProcessId(), 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_NEW_PROCESS,  JobObject, pi[3].dwProcessId, 0);
+    test_job_completion(IOPort, JOB_OBJECT_MSG_EXIT_PROCESS, JobObject, pi[3].dwProcessId, 100);
+
+    ok(!CreateProcessA(NULL, buffer, NULL, NULL, FALSE, CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, &si[0], &pi[0]),
+        "CreateProcess expected failure\n");
+
+    info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_BREAKAWAY_OK;
+
+    ret = pSetInformationJobObject(JobObject, JobObjectExtendedLimitInformation, &info, sizeof(info));
+    ok(ret, "SetInformationJobObject (%d)\n", GetLastError());
+
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, &si[0], &pi[0]),
+        "CreateProcess: (%d)\n", GetLastError());
+    winetest_wait_child_process(pi[0].hProcess);
+
+    if(pIsProcessInJob) {
+        ret = pIsProcessInJob(pi[0].hProcess, JobObject, &out);
+        ok(ret && !out, "IsProcessInJob: expected false (%d)\n", GetLastError());
+    }
+
+    info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
+
+    ret = pSetInformationJobObject(JobObject, JobObjectExtendedLimitInformation, &info, sizeof(info));
+    ok(ret, "SetInformationJobObject (%d)\n", GetLastError());
+
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, &si[0], &pi[0]),
+        "CreateProcess: (%d)\n", GetLastError());
+    winetest_wait_child_process(pi[0].hProcess);
+
+    if(pIsProcessInJob) {
+        ret = pIsProcessInJob(pi[0].hProcess, JobObject, &out);
+        ok(ret && !out, "IsProcessInJob: expected false (%d)\n", GetLastError());
+    }
+}
+
 START_TEST(process)
 {
     BOOL b = init();
@@ -2141,6 +2310,7 @@ START_TEST(process)
     test_SystemInfo();
     test_RegistryQuota();
     test_DuplicateHandle();
+    test_JobObject();
     test_StartupNoConsole();
     /* things that can be tested:
      *  lookup:         check the way program to be executed is searched
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 08fab44..0dd2b34 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -58,6 +58,7 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "winnt.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -567,9 +568,36 @@ NTSTATUS WINAPI NtQueryMutant(IN HANDLE handle,
  */
 NTSTATUS WINAPI NtCreateJobObject( PHANDLE handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
 {
-    FIXME( "stub: %p %x %s\n", handle, access, attr ? debugstr_us(attr->ObjectName) : "" );
-    *handle = (HANDLE)0xdead;
-    return STATUS_SUCCESS;
+    DWORD len = attr && attr->ObjectName ? attr->ObjectName->Length : 0;
+    NTSTATUS ret;
+    struct security_descriptor *sd = NULL;
+    struct object_attributes objattr;
+
+    if (len >= MAX_PATH * sizeof(WCHAR)) return STATUS_NAME_TOO_LONG;
+
+    objattr.rootdir = wine_server_obj_handle( attr ? attr->RootDirectory : 0 );
+    objattr.sd_len = 0;
+    objattr.name_len = len;
+    if (attr)
+    {
+        ret = NTDLL_create_struct_sd( attr->SecurityDescriptor, &sd, &objattr.sd_len );
+        if (ret != STATUS_SUCCESS) return ret;
+    }
+
+    SERVER_START_REQ( create_job )
+    {
+        req->access = access;
+        req->attributes = attr ? attr->Attributes : 0;
+        wine_server_add_data( req, &objattr, sizeof(objattr) );
+        if (objattr.sd_len) wine_server_add_data( req, sd, objattr.sd_len );
+        if (len) wine_server_add_data( req, attr->ObjectName->Buffer, len );
+        ret = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    NTDLL_free_struct_sd( sd );
+    return ret;
 }
 
 /******************************************************************************
@@ -588,8 +616,19 @@ NTSTATUS WINAPI NtOpenJobObject( PHANDLE handle, ACCESS_MASK access, const OBJEC
  */
 NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 {
-    FIXME( "stub: %p %x\n", handle, status );
-    return STATUS_SUCCESS;
+    NTSTATUS ret;
+
+    TRACE( "(%p, %d)\n", handle, status );
+
+    SERVER_START_REQ( terminate_job )
+    {
+        req->handle = wine_server_obj_handle(handle);
+        req->status = status;
+        ret = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    return ret;
 }
 
 /******************************************************************************
@@ -609,8 +648,54 @@ NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS c
  */
 NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info, ULONG len )
 {
-    FIXME( "stub: %p %u %p %u\n", handle, class, info, len );
-    return STATUS_SUCCESS;
+    NTSTATUS status;
+    PJOBOBJECT_ASSOCIATE_COMPLETION_PORT cInfo;
+
+    TRACE( "(%p, %u, %p, %u)\n", handle, class, info, len );
+
+    switch(class)
+    {
+    case JobObjectExtendedLimitInformation:
+        if(len != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION))
+            return STATUS_INVALID_PARAMETER;
+
+        SERVER_START_REQ( job_set_limit )
+        {
+            req->handle = wine_server_obj_handle(handle);
+            req->limit_flags = ((PJOBOBJECT_EXTENDED_LIMIT_INFORMATION)info)->BasicLimitInformation.LimitFlags;
+            status = wine_server_call(req);
+        }
+        SERVER_END_REQ;
+        break;
+    case JobObjectAssociateCompletionPortInformation:
+        if(len != sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT))
+            return STATUS_INVALID_PARAMETER;
+
+        cInfo = (PJOBOBJECT_ASSOCIATE_COMPLETION_PORT)info;
+
+        SERVER_START_REQ( job_set_completion )
+        {
+            req->handle = wine_server_obj_handle(handle);
+            req->CompletionKey = wine_server_client_ptr(cInfo->CompletionKey);
+            req->CompletionPort = wine_server_obj_handle(cInfo->CompletionPort);
+            status = wine_server_call(req);
+        }
+        SERVER_END_REQ;
+        break;
+    case JobObjectBasicAccountingInformation:
+    case JobObjectBasicLimitInformation:
+    case JobObjectBasicProcessIdList:
+    case JobObjectBasicUIRestrictions:
+    case JobObjectSecurityLimitInformation:
+    case JobObjectEndOfJobTimeInformation:
+    case JobObjectBasicAndIoAccountingInformation:
+        status = STATUS_SUCCESS;
+        break;
+    default:
+        status = STATUS_INVALID_INFO_CLASS;
+    }
+
+    return status;
 }
 
 /******************************************************************************
@@ -619,8 +704,18 @@ NTSTATUS WINAPI NtSetInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS cla
  */
 NTSTATUS WINAPI NtIsProcessInJob( HANDLE process, HANDLE job )
 {
-    FIXME( "stub: %p %p\n", process, job );
-    return STATUS_PROCESS_NOT_IN_JOB;
+    NTSTATUS status;
+    TRACE( "(%p %p)\n", job, process );
+
+    SERVER_START_REQ( process_in_job )
+    {
+        req->process_handle = wine_server_obj_handle(process);
+        req->job_handle = wine_server_obj_handle(job);
+        status = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    return status;
 }
 
 /******************************************************************************
@@ -629,8 +724,18 @@ NTSTATUS WINAPI NtIsProcessInJob( HANDLE process, HANDLE job )
  */
 NTSTATUS WINAPI NtAssignProcessToJobObject( HANDLE job, HANDLE process )
 {
-    FIXME( "stub: %p %p\n", job, process );
-    return STATUS_SUCCESS;
+    NTSTATUS status;
+    TRACE( "(%p %p)\n", job, process );
+
+    SERVER_START_REQ( job_assign )
+    {
+        req->job_handle = wine_server_obj_handle(job);
+        req->process_handle = wine_server_obj_handle(process);
+        status = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    return status;
 }
 
 /*
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 02916e9..b29919e 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -676,6 +676,81 @@ struct new_process_reply
     char __pad_28[4];
 };
 
+struct create_job_request
+{
+    struct request_header __header;
+    unsigned int access;
+    unsigned int attributes;
+    /* VARARG(objattr,object_attributes); */
+    char __pad_20[4];
+};
+struct create_job_reply
+{
+    struct reply_header __header;
+    obj_handle_t handle;
+    char __pad_12[4];
+};
+
+struct terminate_job_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          status;
+    char __pad_20[4];
+};
+struct terminate_job_reply
+{
+    struct reply_header __header;
+};
+
+struct process_in_job_request
+{
+    struct request_header __header;
+    obj_handle_t job_handle;
+    obj_handle_t process_handle;
+    char __pad_20[4];
+};
+struct process_in_job_reply
+{
+    struct reply_header __header;
+};
+
+struct job_assign_request
+{
+    struct request_header __header;
+    obj_handle_t job_handle;
+    obj_handle_t process_handle;
+    char __pad_20[4];
+};
+struct job_assign_reply
+{
+    struct reply_header __header;
+};
+
+struct job_set_completion_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    client_ptr_t CompletionKey;
+    obj_handle_t CompletionPort;
+    char __pad_28[4];
+};
+struct job_set_completion_reply
+{
+    struct reply_header __header;
+};
+
+struct job_set_limit_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          limit_flags;
+    char __pad_20[4];
+};
+struct job_set_limit_reply
+{
+    struct reply_header __header;
+};
 
 
 struct get_new_process_info_request
@@ -5123,6 +5198,12 @@ struct set_suspend_context_reply
 enum request
 {
     REQ_new_process,
+    REQ_create_job,
+    REQ_terminate_job,
+    REQ_process_in_job,
+    REQ_job_assign,
+    REQ_job_set_completion,
+    REQ_job_set_limit,
     REQ_get_new_process_info,
     REQ_new_thread,
     REQ_get_startup_info,
@@ -5388,6 +5469,12 @@ union generic_request
     struct request_max_size max_size;
     struct request_header request_header;
     struct new_process_request new_process_request;
+    struct create_job_request create_job_request;
+    struct terminate_job_request terminate_job_request;
+    struct process_in_job_request process_in_job_request;
+    struct job_assign_request job_assign_request;
+    struct job_set_completion_request job_set_completion_request;
+    struct job_set_limit_request job_set_limit_request;
     struct get_new_process_info_request get_new_process_info_request;
     struct new_thread_request new_thread_request;
     struct get_startup_info_request get_startup_info_request;
@@ -5651,6 +5738,12 @@ union generic_reply
     struct request_max_size max_size;
     struct reply_header reply_header;
     struct new_process_reply new_process_reply;
+    struct create_job_reply create_job_reply;
+    struct terminate_job_reply terminate_job_reply;
+    struct process_in_job_reply process_in_job_reply;
+    struct job_assign_reply job_assign_reply;
+    struct job_set_completion_reply job_set_completion_reply;
+    struct job_set_limit_reply job_set_limit_reply;
     struct get_new_process_info_reply get_new_process_info_reply;
     struct new_thread_reply new_thread_reply;
     struct get_startup_info_reply get_startup_info_reply;
diff --git a/server/process.c b/server/process.c
index c62c2ff..61fc0d8 100644
--- a/server/process.c
+++ b/server/process.c
@@ -134,6 +134,178 @@ static const struct object_ops startup_info_ops =
     startup_info_destroy           /* destroy */
 };
 
+/* job object */
+
+static void job_dump_info( struct object *obj, int verbose );
+static unsigned int job_map_access( struct object *obj, unsigned int access );
+static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void job_destroy( struct object *obj );
+static struct object_type *job_get_type( struct object *obj );
+static struct job *get_job_from_handle( struct process *process, obj_handle_t handle, unsigned int access );
+static struct job *create_job_object( struct directory *root, const struct unicode_str *name,
+                                      unsigned int attr, const struct security_descriptor *sd );
+struct job
+{
+    struct object obj;             /* object header */
+    struct list processes;
+    apc_param_t completion_key;
+    struct completion *completion;
+    int num_active;
+    int terminating;
+    int limit_flags;
+};
+
+static const struct object_ops job_ops =
+{
+    sizeof(struct job),            /* size */
+    job_dump_info,                 /* dump */
+    job_get_type,                  /* get_type */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    job_signaled,                  /* signaled */
+    no_satisfied,                  /* satisfied */
+    no_signal,                     /* signal */
+    no_get_fd,                     /* get_fd */
+    job_map_access,                /* map_access */
+    default_get_sd,                /* get_sd */
+    default_set_sd,                /* set_sd */
+    no_lookup_name,                /* lookup_name */
+    no_open_file,                  /* open_file */
+    no_close_handle,               /* close_handle */
+    job_destroy                    /* destroy */
+};
+
+static struct job *create_job_object( struct directory *root, const struct unicode_str *name,
+                                      unsigned int attr, const struct security_descriptor *sd )
+{
+    struct job *job;
+
+    if ((job = create_named_object_dir( root, name, attr, &job_ops )))
+    {
+        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+        {
+            /* initialize it if it didn't already exist */
+            if (sd) default_set_sd( &job->obj, sd, OWNER_SECURITY_INFORMATION|
+                                                   GROUP_SECURITY_INFORMATION|
+                                                   DACL_SECURITY_INFORMATION|
+                                                   SACL_SECURITY_INFORMATION );
+            job->completion_key = 0;
+            job->completion = NULL;
+            job->num_active = 0;
+            job->terminating = 0;
+            job->limit_flags = 0;
+
+            list_init(&job->processes);
+        }
+    }
+    return job;
+}
+
+static struct job *get_job_from_handle( struct process *process, obj_handle_t handle, unsigned int access )
+{
+    return (struct job*)get_handle_obj( process, handle, access, &job_ops );
+}
+
+static struct object_type *job_get_type( struct object *obj )
+{
+    static const WCHAR name[] = {'J', 'o', 'b'};
+    static const struct unicode_str str = { name, sizeof(name) };
+    return get_object_type( &str );
+};
+
+static unsigned int job_map_access( struct object *obj, unsigned int access )
+{
+    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ;
+    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE;
+    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE;
+    if (access & GENERIC_ALL)     access |= JOB_OBJECT_ALL_ACCESS;
+    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
+}
+
+static void job_add_process( struct job *job, struct process *process )
+{
+    if(process->job) {
+        set_error(ERROR_ACCESS_DENIED);
+        return;
+    }
+
+    process->job = (struct job*)grab_object(job);
+
+    job->num_active++;
+
+    if(job->completion)
+        add_completion(
+            job->completion,
+            job->completion_key,
+            get_process_id( process ),
+            STATUS_SUCCESS,
+            JOB_OBJECT_MSG_NEW_PROCESS);
+
+    list_add_tail(&job->processes, &process->job_entry);
+}
+
+static void job_remove_process( struct process *process )
+{
+    struct job *job = process->job;
+
+    if(!job)
+        return;
+
+    assert(job->obj.ops == &job_ops);
+    assert(job->num_active > 0);
+    job->num_active--;
+
+    if(job->completion) {
+        if(!job->terminating) {
+            add_completion(
+                job->completion,
+                job->completion_key,
+                get_process_id( process ),
+                STATUS_SUCCESS,
+                JOB_OBJECT_MSG_EXIT_PROCESS
+            );
+        }
+
+        if(job->num_active == 0) {
+            add_completion(
+                job->completion,
+                job->completion_key,
+                0,
+                STATUS_SUCCESS,
+                JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO
+            );
+            job->terminating = 0;
+        }
+    }
+}
+
+static void job_destroy( struct object *obj )
+{
+    struct job *job = (struct job*)obj;
+    assert(obj->ops == &job_ops);
+    assert(job->num_active == 0);
+
+    if(job->completion)
+        release_object(job->completion);
+}
+
+static void job_dump_info( struct object *obj, int verbose )
+{
+    struct job *job = (struct job *)obj;
+    assert( obj->ops == &job_ops );
+
+    fprintf( stderr, "Job processes=%d\n", list_count(&job->processes) );
+}
+
+static int job_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    return 0;
+}
+
+static int job_breakaway_ok( struct job *job )
+{
+    return (job->limit_flags & (JOB_OBJECT_LIMIT_BREAKAWAY_OK | JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK)) ? 1 : 0;
+}
 
 struct ptid_entry
 {
@@ -328,6 +500,7 @@ struct thread *create_process( int fd, struct thread *parent_thread, int inherit
     process->is_terminating  = 0;
     process->is_terminated   = 0;
     process->console         = NULL;
+    process->job             = NULL;
     process->startup_state   = STARTUP_IN_PROGRESS;
     process->startup_info    = NULL;
     process->idle_event      = NULL;
@@ -425,6 +598,11 @@ static void process_destroy( struct object *obj )
 
     close_process_handles( process );
     set_process_startup_state( process, STARTUP_ABORTED );
+
+    if (process->job) {
+        list_remove(&process->job_entry);
+        release_object( process->job );
+    }
     if (process->console) release_object( process->console );
     if (process->parent) release_object( process->parent );
     if (process->msg_fd) release_object( process->msg_fd );
@@ -709,6 +887,7 @@ static void process_killed( struct process *process )
     remove_process_locks( process );
     set_process_startup_state( process, STARTUP_ABORTED );
     finish_process_tracing( process );
+    job_remove_process( process );
     start_sigkill_timer( process );
     wake_up( &process->obj, 0 );
 }
@@ -931,6 +1110,7 @@ DECL_HANDLER(new_process)
     struct process *parent = current->process;
     int socket_fd = thread_get_inflight_fd( current, req->socket_fd );
     const struct security_descriptor *process_sd = NULL, *thread_sd = NULL;
+    int inherit_job = 0;
 
     if (socket_fd == -1)
     {
@@ -961,6 +1141,20 @@ DECL_HANDLER(new_process)
         return;
     }
 
+    if (parent->job)
+    {
+        if(!(req->create_flags & CREATE_BREAKAWAY_FROM_JOB))
+        {
+            inherit_job = 1;
+        }
+        else if (!job_breakaway_ok(parent->job))
+        {
+            set_error( STATUS_ACCESS_DENIED );
+            close( socket_fd );
+            return;
+        }
+    }
+
     /* build the startup info for a new process */
     if (!(info = alloc_object( &startup_info_ops )))
     {
@@ -1052,6 +1246,8 @@ DECL_HANDLER(new_process)
     process->debug_children = (req->create_flags & DEBUG_PROCESS)
         && !(req->create_flags & DEBUG_ONLY_THIS_PROCESS);
     process->startup_info = (struct startup_info *)grab_object( info );
+    if(inherit_job)
+        job_add_process(parent->job, process);
 
     /* connect to the window station */
     connect_process_winstation( process, current );
@@ -1409,3 +1605,121 @@ DECL_HANDLER(make_process_system)
             shutdown_timeout = add_timeout_user( master_socket_timeout, server_shutdown_timeout, NULL );
     }
 }
+
+DECL_HANDLER(create_job)
+{
+    struct job *job;
+    struct unicode_str name;
+    struct directory *root = NULL;
+    const struct object_attributes *objattr = get_req_data();
+    const struct security_descriptor *sd;
+
+    if (!objattr_is_valid( objattr, get_req_data_size() )) return;
+
+    sd = objattr->sd_len ? (const struct security_descriptor *)(objattr + 1) : NULL;
+    objattr_get_name( objattr, &name );
+
+    if (objattr->rootdir && !(root = get_directory_obj( current->process, objattr->rootdir, 0 ))) return;
+
+    if ((job = create_job_object( root, &name, req->attributes, sd )))
+    {
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, job, req->access, req->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, job, req->access, req->attributes );
+        release_object( job );
+    }
+    if (root) release_object( root );
+}
+
+DECL_HANDLER(job_assign)
+{
+    struct job *job;
+    struct process *process;
+
+    if(!(job = get_job_from_handle( current->process, req->job_handle, JOB_OBJECT_ASSIGN_PROCESS )))
+        return;
+
+    if(!(process = get_process_from_handle( req->process_handle, PROCESS_SET_QUOTA|PROCESS_TERMINATE )))
+        goto error;
+
+    job_add_process( job, process );
+
+    release_object(process);
+error:
+    release_object(job);
+}
+
+DECL_HANDLER(process_in_job)
+{
+    struct job *job;
+    struct process *process, *itter;
+
+    if(!(job = get_job_from_handle( current->process, req->job_handle, JOB_OBJECT_ASSIGN_PROCESS )))
+        return;
+
+    if(!(process = get_process_from_handle( req->process_handle, PROCESS_QUERY_INFORMATION )))
+        goto error;
+
+    set_error(STATUS_PROCESS_NOT_IN_JOB);
+
+    LIST_FOR_EACH_ENTRY(itter, &job->processes, struct process, job_entry )
+    {
+        if(itter == process) {
+            set_error(STATUS_PROCESS_IN_JOB);
+            break;
+        }
+    }
+
+    release_object(process);
+error:
+    release_object(job);
+}
+
+DECL_HANDLER(terminate_job)
+{
+    struct job *job;
+    struct process *process;
+
+    if(!(job = get_job_from_handle( current->process, req->handle, JOB_OBJECT_TERMINATE )))
+        return;
+
+    job->terminating = 1;
+
+    LIST_FOR_EACH_ENTRY(process, &job->processes, struct process, job_entry )
+    {
+        terminate_process(process, NULL, req->status);
+    }
+
+    release_object(job);
+}
+
+DECL_HANDLER(job_set_completion)
+{
+    struct job *job;
+    struct completion *completion;
+
+    if(!(job = get_job_from_handle( current->process, req->handle, JOB_OBJECT_SET_ATTRIBUTES )))
+        return;
+
+    if(!(completion = get_completion_obj( current->process, req->CompletionPort, 0 )))
+        goto error;
+
+    job->completion_key = req->CompletionKey;
+    job->completion = completion;
+
+error:
+    release_object(job);
+}
+
+DECL_HANDLER(job_set_limit)
+{
+    struct job *job;
+
+    if(!(job = get_job_from_handle( current->process, req->handle, JOB_OBJECT_SET_ATTRIBUTES )))
+        return;
+
+    job->limit_flags = req->limit_flags;
+
+    release_object(job);
+}
diff --git a/server/process.h b/server/process.h
index da6d3da..5ec3d9e 100644
--- a/server/process.h
+++ b/server/process.h
@@ -26,6 +26,7 @@
 struct atom_table;
 struct handle_table;
 struct startup_info;
+struct job;
 
 /* process startup state */
 enum startup_state { STARTUP_IN_PROGRESS, STARTUP_DONE, STARTUP_ABORTED };
@@ -60,6 +61,8 @@ struct process
     struct thread       *debugger;        /* thread debugging this process */
     struct handle_table *handles;         /* handle entries */
     struct fd           *msg_fd;          /* fd for sendmsg/recvmsg */
+    struct job          *job;             /* job object ascoicated with this process */
+    struct list          job_entry;       /* list entry for job object */
     process_id_t         id;              /* id of the process */
     process_id_t         group_id;        /* group id of the process */
     struct timeout_user *sigkill_timeout; /* timeout for final SIGKILL */
diff --git a/server/protocol.def b/server/protocol.def
old mode 100755
new mode 100644
index 1d96901..127486d
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -685,6 +685,39 @@ struct rawinput_device
     obj_handle_t thandle;        /* thread handle (in the current process) */
 @END
 
+@REQ(create_job)
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    VARARG(objattr,object_attributes); /* object attributes */
+@REPLY
+    obj_handle_t handle;        /* handle to the job */
+@END
+
+@REQ(terminate_job)
+    obj_handle_t handle;
+    int          status;
+@END
+
+@REQ(process_in_job)
+    obj_handle_t job_handle;
+    obj_handle_t process_handle;
+@END
+
+@REQ(job_assign)
+    obj_handle_t job_handle;
+    obj_handle_t process_handle;
+@END
+
+@REQ(job_set_completion)
+    obj_handle_t handle;
+    client_ptr_t CompletionKey;
+    obj_handle_t CompletionPort;
+@END
+
+@REQ(job_set_limit)
+    obj_handle_t handle;
+    int          limit_flags;
+@END
 
 /* Retrieve information about a newly started process */
 @REQ(get_new_process_info)
diff --git a/server/request.h b/server/request.h
index 2cc0c2a..c56927f 100644
--- a/server/request.h
+++ b/server/request.h
@@ -107,6 +107,12 @@ static inline void set_reply_data_ptr( void *data, data_size_t size )
 /* ### make_requests begin ### */
 
 DECL_HANDLER(new_process);
+DECL_HANDLER(create_job);
+DECL_HANDLER(terminate_job);
+DECL_HANDLER(process_in_job);
+DECL_HANDLER(job_assign);
+DECL_HANDLER(job_set_completion);
+DECL_HANDLER(job_set_limit);
 DECL_HANDLER(get_new_process_info);
 DECL_HANDLER(new_thread);
 DECL_HANDLER(get_startup_info);
@@ -371,6 +377,12 @@ typedef void (*req_handler)( const void *req, void *reply );
 static const req_handler req_handlers[REQ_NB_REQUESTS] =
 {
     (req_handler)req_new_process,
+    (req_handler)req_create_job,
+    (req_handler)req_terminate_job,
+    (req_handler)req_process_in_job,
+    (req_handler)req_job_assign,
+    (req_handler)req_job_set_completion,
+    (req_handler)req_job_set_limit,
     (req_handler)req_get_new_process_info,
     (req_handler)req_new_thread,
     (req_handler)req_get_startup_info,
@@ -678,6 +690,27 @@ C_ASSERT( FIELD_OFFSET(struct new_process_reply, phandle) == 16 );
 C_ASSERT( FIELD_OFFSET(struct new_process_reply, tid) == 20 );
 C_ASSERT( FIELD_OFFSET(struct new_process_reply, thandle) == 24 );
 C_ASSERT( sizeof(struct new_process_reply) == 32 );
+C_ASSERT( FIELD_OFFSET(struct create_job_request, access) == 12 );
+C_ASSERT( FIELD_OFFSET(struct create_job_request, attributes) == 16 );
+C_ASSERT( sizeof(struct create_job_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct create_job_reply, handle) == 8 );
+C_ASSERT( sizeof(struct create_job_reply) == 16 );
+C_ASSERT( FIELD_OFFSET(struct terminate_job_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct terminate_job_request, status) == 16 );
+C_ASSERT( sizeof(struct terminate_job_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct process_in_job_request, job_handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct process_in_job_request, process_handle) == 16 );
+C_ASSERT( sizeof(struct process_in_job_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct job_assign_request, job_handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct job_assign_request, process_handle) == 16 );
+C_ASSERT( sizeof(struct job_assign_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct job_set_completion_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct job_set_completion_request, CompletionKey) == 16 );
+C_ASSERT( FIELD_OFFSET(struct job_set_completion_request, CompletionPort) == 24 );
+C_ASSERT( sizeof(struct job_set_completion_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct job_set_limit_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct job_set_limit_request, limit_flags) == 16 );
+C_ASSERT( sizeof(struct job_set_limit_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_new_process_info_request, info) == 12 );
 C_ASSERT( sizeof(struct get_new_process_info_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_new_process_info_reply, success) == 8 );
diff --git a/server/trace.c b/server/trace.c
index b8fc478..696303b 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1118,6 +1118,49 @@ static void dump_new_process_reply( const struct new_process_reply *req )
     fprintf( stderr, ", thandle=%04x", req->thandle );
 }
 
+static void dump_create_job_request( const struct create_job_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    dump_varargs_object_attributes( ", objattr=", cur_size );
+}
+
+static void dump_create_job_reply( const struct create_job_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_terminate_job_request( const struct terminate_job_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", status=%d", req->status );
+}
+
+static void dump_process_in_job_request( const struct process_in_job_request *req )
+{
+    fprintf( stderr, " job_handle=%04x", req->job_handle );
+    fprintf( stderr, ", process_handle=%04x", req->process_handle );
+}
+
+static void dump_job_assign_request( const struct job_assign_request *req )
+{
+    fprintf( stderr, " job_handle=%04x", req->job_handle );
+    fprintf( stderr, ", process_handle=%04x", req->process_handle );
+}
+
+static void dump_job_set_completion_request( const struct job_set_completion_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    dump_uint64( ", CompletionKey=", &req->CompletionKey );
+    fprintf( stderr, ", CompletionPort=%04x", req->CompletionPort );
+}
+
+static void dump_job_set_limit_request( const struct job_set_limit_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", limit_flags=%d", req->limit_flags );
+}
+
 static void dump_get_new_process_info_request( const struct get_new_process_info_request *req )
 {
     fprintf( stderr, " info=%04x", req->info );
@@ -4125,6 +4168,12 @@ static void dump_set_suspend_context_request( const struct set_suspend_context_r
 
 static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_request,
+    (dump_func)dump_create_job_request,
+    (dump_func)dump_terminate_job_request,
+    (dump_func)dump_process_in_job_request,
+    (dump_func)dump_job_assign_request,
+    (dump_func)dump_job_set_completion_request,
+    (dump_func)dump_job_set_limit_request,
     (dump_func)dump_get_new_process_info_request,
     (dump_func)dump_new_thread_request,
     (dump_func)dump_get_startup_info_request,
@@ -4386,6 +4435,12 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_new_process_reply,
+    (dump_func)dump_create_job_reply,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
     (dump_func)dump_get_new_process_info_reply,
     (dump_func)dump_new_thread_reply,
     (dump_func)dump_get_startup_info_reply,
@@ -4647,6 +4702,12 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
 
 static const char * const req_names[REQ_NB_REQUESTS] = {
     "new_process",
+    "create_job",
+    "terminate_job",
+    "process_in_job",
+    "job_assign",
+    "job_set_completion",
+    "job_set_limit",
     "get_new_process_info",
     "new_thread",
     "get_startup_info",
@@ -5006,7 +5067,9 @@ static const struct
     { "PIPE_LISTENING",              STATUS_PIPE_LISTENING },
     { "PIPE_NOT_AVAILABLE",          STATUS_PIPE_NOT_AVAILABLE },
     { "PRIVILEGE_NOT_HELD",          STATUS_PRIVILEGE_NOT_HELD },
+    { "PROCESS_IN_JOB",              STATUS_PROCESS_IN_JOB },
     { "PROCESS_IS_TERMINATING",      STATUS_PROCESS_IS_TERMINATING },
+    { "PROCESS_NOT_IN_JOB",          STATUS_PROCESS_NOT_IN_JOB },
     { "SECTION_TOO_BIG",             STATUS_SECTION_TOO_BIG },
     { "SEMAPHORE_LIMIT_EXCEEDED",    STATUS_SEMAPHORE_LIMIT_EXCEEDED },
     { "SHARING_VIOLATION",           STATUS_SHARING_VIOLATION },
